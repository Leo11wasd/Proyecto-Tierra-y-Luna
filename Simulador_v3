#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include "Movils.cpp"
#include "VEC3.h"

#include <iostream>
#include <cmath>
#include "linmath.h"

#include "Resorte_03_Caras.cpp"
VEC3 pos_1 = {0.0, 0.0, 0.0};
VEC3 vel_1 = {0.0, 0.0, 0.0};

VEC3 pos_2 = {384.403E6, 0.0, 0.0};
VEC3 vel_2 = {0.0, 946.6322, 0.0};

double deltaT = 1.0 * 3600; // segundos en una hora
//double t_horas = 0.0f;

Movil mov_1("Tierra", 5.9736E24, pos_1, vel_1);
Movil mov_2("  Luna", 7.35E22, pos_2, vel_2);

void generaPosiciones() {
  //t_horas += deltaT / 3600;

  mov_1.limpiaFza();
  mov_2.limpiaFza();

  mov_1.interactua(&mov_2);

  mov_1.mueve(deltaT);
  mov_2.mueve(deltaT);

  // mov_2.impFza();

  VEC3 dr;
  float radio;
  dr = mov_2.r - mov_1.r;

  radio = dr.norma();
}
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// settings
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

const char *vertexShaderSource ="#version 330 core\n"
    "uniform mat4 MVP;\n"
    "layout (location = 0) in vec3 aPos;\n"
    "layout (location = 1) in vec3 aCol;\n"
    "out vec3 color;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = MVP * vec4(aPos.x,aPos.y,aPos.z, 1.0);\n"
    "   color = aCol;\n"
    "}\0";

const char *fragmentShaderSource = "#version 330 core\n"
    "out vec4 FragColor;\n"
    "//uniform vec4 ourColor;\n"
    "in vec3 color;\n"
    "void main()\n"
    "{\n"
    "   FragColor = vec4(color,1.0);//ourColor;\n"
    "}\n\0";

int main()
{
    float x,y,z;
    GLint mvp_location, vpos_location, vcol_location;

    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Simulador Tierra-Luna", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    // build and compile our shader program
    // ------------------------------------
    // vertex shader
    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    // check for shader compile errors
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
    }
    // fragment shader
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
    // check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
    }
    // link shaders
    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
    }

    mvp_location = glGetUniformLocation(shaderProgram, "MVP");
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    int num_indices;


    int           num_vertices_tierra;
    int           num_indices_tierra;
    VERTICE      *vertices_tierra;
    unsigned int *indices_tierra;

    int           num_vertices_luna;
    int           num_indices_luna;
    VERTICE      *vertices_luna;
    unsigned int *indices_luna;


    int LUNA = 1;
    int ESFERA = 2;


    creaSolRevCaras(ESFERA,
                    &num_vertices_tierra, &vertices_tierra, // notense los & para obtener el lugar de memoria (referencia) de las variables
                    &num_indices_tierra,  &indices_tierra);

    creaSolRevCaras(ESFERA,
                    &num_vertices_luna, &vertices_luna, // notense los & para obtener el lugar de memoria (referencia) de las variables
                    &num_indices_luna,  &indices_luna);


    //
    // se despliegan ambos arreglos
    //
    // printf("modificar_072_SolRev: nu_vertices=%d, num_indices=%d\n",num_vertices_luna, num_indices_luna);

    /* int k,j,ikj;

     for(k = 0; k < num_vertices; k++) printf("%d %f %f %f %f %f %f\n",k,vertices[k].x,vertices[k].y,vertices[k].z,vertices[k].r,vertices[k].g,vertices[k].b);
     ikj = 0;
     for(k = 0; k < num_indices / 3; k++) for(j = 0; j < 3; j++) printf("%d %d %d\n",k,j,indices[ikj++]);
    */

    // codigo como siempre (solo se cambiaron los tamaÃ±os de los arreglos para estos datos)



    // ================================================================================
    //                               TIERRA
    // ================================================================================

    unsigned int VBO_tierra, VAO_tierra, EBO_tierra;

    {
      glGenVertexArrays(1, &VAO_tierra);
      glGenBuffers(1,      &VBO_tierra);
      glGenBuffers(1,      &EBO_tierra);

      num_indices = num_indices_tierra;


      glBindVertexArray(VAO_tierra);

      glBindBuffer(GL_ARRAY_BUFFER, VBO_tierra);
      glBufferData(GL_ARRAY_BUFFER, num_vertices_tierra*sizeof(VERTICE), vertices_tierra, GL_STATIC_DRAW);

      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(VERTICE), (void*)0);
      glEnableVertexAttribArray(0);
      glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(VERTICE), (void*)(3*sizeof(float)));
      glEnableVertexAttribArray(1);

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO_tierra);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, num_indices_tierra * sizeof(unsigned int), indices_tierra, GL_STATIC_DRAW);

    }
    // ================================================================================
    //                              FIN DE TIERRA
    // ================================================================================
   // ================================================================================
    //                               LUNA
    // ================================================================================

    unsigned int VBO_luna, VAO_luna, EBO_luna;

    //if(TIPO == PRISMA)
    {
      glGenVertexArrays(1, &VAO_luna);
      glGenBuffers(1, &VBO_luna);
      glGenBuffers(1, &EBO_luna);

      num_indices = num_indices_luna;

      // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
      glBindVertexArray(VAO_luna);

      glBindBuffer(GL_ARRAY_BUFFER, VBO_luna);
      glBufferData(GL_ARRAY_BUFFER, num_vertices_luna*sizeof(VERTICE), vertices_luna, GL_STATIC_DRAW);

      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(VERTICE), (void*)0);
      glEnableVertexAttribArray(0);
      glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(VERTICE), (void*)(3*sizeof(float)));
      glEnableVertexAttribArray(1);

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO_luna);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, num_indices_luna * sizeof(unsigned int), indices_luna, GL_STATIC_DRAW);

    }
    // ================================================================================
    //                               FIN DE LUNA
    // ================================================================================

    // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
    // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
    // glBindVertexArray(0);


    // bind the VAO (it was already bound, but just to demonstrate): seeing as we only have a single VAO we can
    // just bind it beforehand before rendering the respective triangle; this is another approach.


    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);
    glFrontFace(GL_CCW);


    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.4f, 0.4f, 0.4f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // be sure to activate the shader before any calls to glUniform
        glUseProgram(shaderProgram);

		float ratio;
		int width, height;
		mat4x4 m, p, mvp,pers,mk,mtr;

		glfwGetFramebufferSize(window, &width, &height);
		ratio = width / (float)height;

		glViewport(0, 0, width, height);
		//glClear(GL_COLOR_BUFFER_BIT);

		//mat4x4_identity(m);
		//mat4x4_rotate_X(m, m, (float)glfwGetTime());
		//mat4x4_rotate_Y(m, m, (float)glfwGetTime());

		//mat4x4_ortho( p, -ratio, ratio, -1.f, 1.f, 1.f, -1.f);
		//mat4x4_mul(mvp, p, m);

		float tr_y[2] = { 0.3f, -0.3f}; //{ 0.3f, -0.3f};
		float tr_x[2] = { 0.3f, -0.3f}; //{ 0.3f, -0.3f};
		float tr_z[2] = {-6.0f, -5.0f}; //{-6.0f, -5.0f};

		mat4x4_perspective(pers,30.0*atan(1.0)/45.0,800.0/600.0,
                           0.0f,10.0f);

for(int t= 0; t < 2; t++)
    //1 -> TIERRA
    //0 ->LUNA
        {
        generaPosiciones();

          mat4x4_identity(m);
	//	  mat4x4_rotate_X(m, m, (t == 1?0.5:1.0) * (float)glfwGetTime());
		//  mat4x4_rotate_Y(m, m, (t == 1?0.5:1.0) * (float)glfwGetTime());
          mat4x4_rotate_Z(m, m, (t == 1?0.5:1.0) * (float)glfwGetTime());

          mat4x4_dup(mk,m);
        if(t==1){
        x=mov_1.r.x/4e8;
        y=mov_1.r.y/4e8;
        }else{
        x=mov_2.r.x/4e8;
        y=mov_2.r.y/4e8;
        }
        z=-6.0;
		  mat4x4_translate(mtr,x,y,z);

          mat4x4_mul(mk,mtr,mk);
		  mat4x4_mul(mvp, pers, mk);

		  glUniformMatrix4fv(mvp_location, 1, GL_FALSE, (const GLfloat*)mvp);

          if(t == 1)

              glBindVertexArray(VAO_tierra);
          else
              glBindVertexArray(VAO_luna);


          glDrawElements(GL_TRIANGLES,num_indices,GL_UNSIGNED_INT,0);
        }
/*
          mat4x4_identity(m);

		  mat4x4_rotate_Y(m, m, (1.0) * (float)glfwGetTime());


          mat4x4_dup(mk,m);
        generaPosiciones();
        //este es uno. hay q aplicarselo a los dos
        mat4x4_translate(mtr,mov_2.r.x/4.2e8,mov_2.r.y/4.2e8,-6.0f);

          mat4x4_mul(mk,mtr,mk);
		  mat4x4_mul(mvp, pers, mk);

		  glUniformMatrix4fv(mvp_location, 1, GL_FALSE, (const GLfloat*)mvp);


              glBindVertexArray(VAO_tierra);


          glDrawElements(GL_TRIANGLES,num_indices,GL_UNSIGNED_INT,0);
*/
        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // optional: de-allocate all resources once they've outlived their purpose:
    // ------------------------------------------------------------------------


      glDeleteVertexArrays(1, &VAO_tierra);
      glDeleteBuffers(1,      &VBO_tierra);
      glDeleteBuffers(1,      &EBO_tierra);

      glDeleteVertexArrays(1, &VAO_luna);
      glDeleteBuffers(1,      &VBO_luna);
      glDeleteBuffers(1,      &EBO_luna);

    glDeleteProgram(shaderProgram);

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();
    return 0;
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow *window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
}
